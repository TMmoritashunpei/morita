-ne not=
-eq =


caseは終了の流れが無いと流れてしまう
■case文

#!/bin/bash

case $1 in
	start)
		echo '開始します'
		;;
		stop)
		echo '停止します'
		;;
		*)　　　　　上記以外のすべて
		echo '引数にstartかstopをつけてください'
		;;
	esac



ネスティング構造が深い
一流は難しいことを簡単に書く
ダメな人は簡単な事を難しく考える。

■for文

#!/bin/bash
for file in `ls`

do
	cp -p "$file" "$file".bk
done

lsコマンドをしてファイル
コピーする


#!/bin/bash

sum=0
for ((i = 1; i <=100; i++)) {
	((sum +=i))
}
echo "$sum"


■while until 文


#!/bin/bash

sum=0
i=1
while [ "$i" -le 100 ]
do
sum=`expr "$sum" + "$i"`
i=`expr "$i" + 1`
done
echo "$sum"


-le
レスザン
>=
-ge
グレータスザン
<=

#!/bin/bash
■select

PS3='コマンド？'
select cmd in up down left right look quit
do
	case $cmd in
		up)
		echo '上に移動しました';;
		down)
		echo '下に移動しました';;
		left)
		echo '左に移動しました';;
		right)
		echo '右に移動しました';;
		look)
		echo 'アイテムが落ちています';;
		quit)
		echo '終了します'
		break;;
		*)
		echo "$REPLY"'というコマンドはありません';;

		esac
		echo
		done

■サブシェル
    -x はデバッグモード

    #!/bin/bash

    (
     cd /home/ec2-user/0831
     cp -p "$1" backup."$1"
    )

    #!/bin/bash

    (
     cd /home/ec2-user/0831
     cp -p "$1" backup."$1"
    )
    #!/bin/bash
    (
    cd /home/ec2-user/0831
    pwd
    ls -l
    ) > logfile.log
> リダイレクト　上書き保存
>>　追記モード

グループコマンド

グループ外にも変数の代入などが影響される。


シェル関数
メソッド


#!/bin/bash

func()
{
	echo 'シエルが実行されました'
}

func


func()

func 呼び出す

[ec2-user@ip-30-0-10-87 0831]$ sh -x func.sh
+ func
+ echo シエルが実行されました
シエルが実行されました
[ec2-user@ip-30-0-10-87 0831]$
func実行された


#!/bin/bash

func(arg arg2 arg3)
{
	echo 'arg'
  echo 'arg2'
  echo 'arg3'
}
aaa=$1
bbb=$2
ccc=$3
func $aaa $bbb $ccc

$ 一つ　二個目は評価しないという
＄＄二個目も評価

参考演算子
式１?　式２ ;式3
式1が真なら　式２
違うなら式３


.コマンド


#!/bin/bash
TEST_VAL=hello


.コマンド
TEST_VAL=
. ./src_test.sh
echo "$TEST_VAL"

表示される
読み込んで実行する

TEST_VAL=
./src_test.sh
echo "$TEST_VAL"

表示されない
別のプロセスが起動している
から
TEST_VAL=helloの状態が保持されない

source file
.と一緒

exit を.ファイルで読み込むテキストに記入していると元のシェルが強制終了されてしまう。

break は言語によって抜ける部分が変わるが操作することができる。

引数N 付けるとN重ループ抜けることができる。

continue
この回の実行次の回のループに進む


cd -P リンク
リンク先に物理移動する。

ln -s /usr/local/リンクを作る

100人規模のシステムの方が勉強になる

■eval
危ない
ハッカーに使っているのにばれたら
サーバーに乗っ取られる。

パラメータ展開
引数
呼び込んだらパラメータ
＄１パラメータ展開

コマンド置換
``で囲ってあげることにより実行することができるその中身が展開される。

eval

#!/bin/bash

day0=Sunday day1=Monday day3=Tuesday day4=Thursday day5=Friday day6=Saturday
today=day3
eval echo \"\$$today\"


[ec2-user@ip-30-0-10-87 0831]$ day0=Sunday day1=Monday day3=Tuesday day4=Thursday day5=Friday day6=Saturday
[ec2-user@ip-30-0-10-87 0831]$ today=day5
[ec2-user@ip-30-0-10-87 0831]$ echo \"\$$today\"
"$day5"
[ec2-user@ip-30-0-10-87 0831]$

evalが二重に展開をしている
からday5=Fridayが表示する

\\$\が展開ごとに消える

■exec
dockerも使っている

新しいプロセスを作らず起動する


ラッパースクリプト

処理がまとめられたもの
ひとまとめにしてスクリプトに入れてあるもの

色々な機能が一つにまとめられている。


$@ 全ての引数が展開される。

$#は引数の数を表示する。

$?終了ステータス。

export ログインシェルに記入しておけばずっと使うことができる。

代入の前でもOK
unset　export取消


■set

■tar


#!/bin/bash
func $1

func() {
	if { ! -f "$1" }; then
	echo "$1"'ファイルが存在しません'
	return 1
fi
	cp -p "$1" "$1".bak
	return 0
}
