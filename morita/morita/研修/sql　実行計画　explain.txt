sql実行計画

sql文にexplainをつけると
実行計画が表示される。
mysql> explain select * from postal_code where pref = "���s�{";
+----+-------------+-------------+------------+------+-----------------------+------+---------+-------+-------+----------+-------+
| id | select_type | table       | partitions | type | possible_keys         | key  | key_len | ref   | rows  | filtered | Extra |
+----+-------------+-------------+------------+------+-----------------------+------+---------+-------+-------+----------+-------+
|  1 | SIMPLE      | postal_code | NULL       | ref  | IX_postal_code_1,pref | pref | 26      | const | 25040 |   100.00 | NULL  |
+----+-------------+-------------+------------+------+-----------------------+------+---------+-------+-------+----------+-------+
1 row in set, 1 warning (0.00 sec)

possible_keys　候補のインデックス


key　実行されたインデックス

rows　25040 少ないほうがいい。
インデックス　作り方
alter table postal_code add index jis_code(jis_code);

インデックス確認
show index from postal_code from post;

マルチインデックス
ALTER TABLE postal_code ADD INDEX (city,postal7,jis_code,postal5);

インデックス削除
ALTER TABLE postal_code DROP INDEX jis_code;



複雑なsqlで実行計画を取る
結果が帰ってこないがインデックスつけることによって
実行速度が改善される。

select DISTINCT p1.jis_code,p1.postal_id,p1.postal5,p1.pref_kana,p1.city_kana,p1.pref,p1.city,p1.address,(select flag1 from postal_code_base where postal5 = "64"),(select postal7 from postal_code_base where postal5 = "64") from postal_code p1 join postal_code_base b1 on p1.jis_code = b1.jis_code inner join  postal_code_base b2 on p1.postal7 = b2.postal7 where p1.postal5 between 64 and 75;





select DISTINCT p1.jis_code,p1.postal_id,p1.postal5,p1.pref_kana,p1.city_kana,p1.pref,p1.city,p1.address,(select flag1 from postal_code_base where postal5 = "64"),(select postal7 from postal_code_base where postal5 = "64") from postal_code p1 join postal_code_base b1 on p1.jis_code = b1.jis_code left join  postal_code_base b2 on p1.postal7 = b2.postal7 left join where p1.postal5 between 64 and 75;
